# const 与 * 与 &

## 1. const限定符

const限定符常常被用于定义常量，例如

```c
const int bufsize=512;	//输入缓冲区大小
```

上示例中，定义了一个int型的常量bufsize。之后任何为bufsize赋值的操作都将会引发错误。因为const对象一但定义后其值就无法改变，所以const对象必须初始化。

```c
const int i = get_size();	//正确：运行时初始化成功
const int j = 42;			//正确：编译时初始化
const int k;				//正确：为进行初始化操作
```

## 2.引用

引用的本质为为对象起一个新的名字，引用类型引用（refers to）另外一种类型，通过声明符写成&d的形式来定义引用类型，其中d是声明的变量名，引用并非对象，它只是一个已经存在的对象的另外一个名字，定义了一个引用后，对其所有的操作都是再与之绑定的对象上进行的。

* 引用类型的初始值必须是一个对象

* 引用类型的初始值必须和引用本身同类型

##  3. 指针



指针与引用类似，指针也可以实现对其他对象的间接访问。而指针与引用还是有很多不同。

1. **指针本身就是一个==对象==**，允许对指针进行赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象，
2. 指针无需再定义时初始化，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成*d的形式，其中d石变量名。如果在一条语句中定义了几个指针变量，每个变量前面必须有符号 “ * ”。

```c
int *p1,*p2;//p1和p2都是指向int型的指针
double dp,*dp2;//dp2是指向double类型对象的指针，dp是double型的对象
```

指针存放的是某一个对象的地址，想要获取该地址，需要使用取地址符（&）

```c
int ival=42;
int *p=&ival;
```

### 指针值
>
> 1. 指向一个对象。
> 2. 指向紧邻对象所占空间的下一个位置。
> 3. 空指针，意味着没有指向任何对象。
> 4. 无效指针，

### 利用指针访问对象
>
> 如果指针指向了一个对象，则允许使用解引用符（*）来访问该对象
>
> > #### 引用的指针
> >
> > 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针
>
> 
>
> ```c
> int ival=42;
> int *p=&ival;
> cout<<*p;
> //输出42。
> ```

### 空指针
>
> 空指针不指向任何对象，试图使用一个指针之前应该判断其是否为空：

> 指针与引用的区别
>
> 指针之所以可以对指向的值进行操作，是因为指针储存了其所指对象在内存中的位置，所以指针在内存中也占有一定的空间。
>
> 引用并不在内存中分配到额外空间，也就是说，引用是

## 4. const的引用（*常量的引用*）

可以把引用对象绑定到const对象上，我们称之为对常量的引用，不过对常量的引用不能被用作修改其所绑定的对象。不可使一个非常量的引用指向一个常量对象。

const的引用是一个赋值的过程，如果给const引用的数换成一个变量，编译正常，但是再给变量重新赋值后，const引用值不发生改变。同时，要注意的是，在引用过程中如果发生类型转换，编译器会临时生成一个与引用对象同类型的常量

## 5. 指针与const

>  指针的本质是一个对象，并且它可以指向另外一个对象。因此，关于指针与const的问题可以看成指针本身是一个常量与指针所指的对象为常量，指针的const既可以是顶层const，又可以是底层const。

1.  顶层的指针const不可以改变指向对象
2.  底层的const指针可以改变指针的值
3.  在进行赋值时，不能用一个底层的值初始化顶层，进行赋值操作的左值和右值都必须有const资格


```c++
    int i=0;			//这是一个整型变量
    int *const p1=&i;	//这是一个顶层const，p1的值无法改变
    const int ci=42;	//这是一个整型常量（顶层const），ci的值无法改变
    const int *p2=&ci;	//这是一个底层const，允许改变p2的值
    const int *const p3=p2;//靠右的const为顶层const，靠左的const是底层const
    const int &r=c1;	//用于声明引用的const都是底层const
```

## 6. 顶层const（top-level const）



1.  顶层const可以表示任何的对象为常量，对于任意数据类型都适用。
2.  顶层const不可以改变指向对象

### 6.1 底层const（low-level const）

1.  底层const与指针和引用等复合类型有关，



## 7. constexpr与常量表达式

### constexpr变量

C++11新特性：允许把变量声明为constexpr类型以便编译器来验证变量的值==是否==是一个*常量表达式*。声明为constexpr的变量一定是一个常量表达式。

>  常量表达式：值不会发生改变且在编译过程中就能得到计算结果

该新特新下，允许进行定义一个新的函数类型——constexpr函数。这种函数足够简单，可以在编译时就得到答案。

### 字面值类型

因为常量表达式必须在编译时得到计算，所以对于声明constexpr时用到的变量必须加以限制，因为这些类型比较简单，值显而易见，就把他们称为字面值类型（literal type）。

算数值类(bool\char\short\int\long\float\double等),引用(&),和指针(*)都是字面值类型。

尽管指针与引用都能定义成constexpr,但其初始值被严格限定。

### constexpr函数

定义方法与其他函数相同，不过函数返回值与其他形参必须都是字面值类型

### 指针与constexpr

