# 面向对象

C++与C的不同

![image-20230603182004249](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603182004249.png)

对于面向过程的函数来说，程序中的变量可以被任意的函数调用，儿面向对象编程时，变量与操作变量的函数被打包在一起，他们都是对象的成员，只有自己的成员函数可以操控自己的成员变量。

![image-20230603183731550](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603183731550.png)

对于一个类来说，不同的对象变量有不同的数据，但是成员函数只有一份

>   C++代码基本格式
>
>   ![image-20230603184320264](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603184320264.png)
>
>   C++与C语言风格对比
>
>   ![image-20230603184529993](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603184529993.png)
>
>   

## c++头文件写法（在引用头文件时判断是否被引用过）

![image-20230603184721496](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603184721496.png)



## 开始



![image-20230603185118732](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603185118732.png)




![image-20230603185215407](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603185215407.png)



```c++
//1
class complex                 //函数头
{
public:                       //公开的
  complex (double r = 0, double i = 0): re (r), im (i) { }
  complex& operator += (const complex&);
  double real () const { return re; }
  double imag () const { return im; }
private:                       //私有的
  double re, im;

  friend complex& __doapl (complex *, const complex&);
};
 // 2-2
inline double
imag (const complex& x)
{
  return x.imag ();
}

```



## 模板

![image-20230603185743306](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603185743306.png)

## `inline`（内联）函数

以个`inline`函数相比于普通函数可以更快的执行，但是我们标记的`inline`函数是给编译器一个建议，函数是不是`inline`由编译器决定。

## 访问级别

`public`：公共的、公开的

`private`：封装的，可以通过`public`访问，不能直接在环境中访问

`publiced`：保护的

![image-20230603190831749](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603190831749.png)

错误原因：数据为私有成员，私有成员不能在函数中直接使用，只能通过公开部分使用 

### 构造函数

每个类都有创建自己的方式，创建类的函数叫做构造函数。

1.   构造函数的名称与函数值相同；

2.   构造参数可以传参，参数可以有默认值；

3.   构造函数没有返回值；

4.   构造函数有特殊的写法

     `类名(参数):Data1(赋值1), Data2(赋值2), ...{}`

5.   构造函数可以有多个，这种方式叫做重载，重载的构造函数不能传入相同的参数；

6.   构造函数有函数重载时，不能有函数传参默认值；

```c++
complex (double r = 0, double i = 0): re (r), im (i) { }
// complex (): re (0), im (0) { }
```

当一个对象不允许被外界直接创造时，它可以把构造函数放在`private`中，在`Singleton`（单例、单体）设计模式中，构造函数被放在`private`中，它不能直接创造。但是可以通过在`public`中的`static`函数得到这个类。

## `const`申明符

1.   表示数据是不会发生改变的，`const`的数据不允许被改变，`const`函数中不会改变数据；
2.   被`const`限制的类只可以调用`const`函数。

## 使用引用进行参数传递与值的返回（pass by value VS pass by referece(to const)，return by value VS ruturn by reference）

```c++
class complex
{
public:
  complex (double r = 0, double i = 0): re (r), im (i) { }
  complex& operator += (const complex&);
  double real () const { return re; }
  double imag () const { return im; }
private:
  double re, im;

  friend complex& __doapl (complex *, const complex&);
};
```

![image-20230604033847953](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230604033847953.png)

1.   传递参数时尽量使用引用，引用的传递与指针差不多；
2.   传递的引用会改变传递参数的值，和传递指针的效果相当；
3.   当不希望传递的引用被改变时，应该给引用加上`const`限定符；
4.   在可以的情况下，将函数的返回值定义为引用

### `class` body 外的各种定义

>   什么时候使用pass by reference
>
>   什么时候使用return by reference  

当要返回的值在离开作用域后就被销毁时，不可以传递引用。引用实现的是一个参数的间接使用，所以`return`引用的成员必须在外面的作用域存在

当函数的计算值可以存储在已有的空间时，将该函数设计为返回值为引用的，如果函数的返回值保存在函数中新建的对象中时，不可以返回引用；



## 友元（froend)

```c++
friend complex& __doapl (complex *, const complex&);
```

被封装的类中`private`的内容除了使用类自身中的函数调用，还可以使用froend（友元）调用，但是友元的出现打破了类的封装。所以我们需要在程序中调用封装好的类成员时，一种方法是设计相关的接口，另一种是将其设计为友元，

### **相同的`class`的各个`objects`互为`friends`**

![image-20230604040210828](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230604040210828.png)

## 操作符重载

在C++中，操作符是一个函数。

![image-20230604154840850](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230604154840850.png)

所以的成员函数都有一个默认的参数叫做`this` 

传递者无需知道接受者使用引用的方式传递

```c++
#include <iostream>
using namespace std;

class date
{
public:
    date():a(0), b(0){}
    date(int x):a(x), b(0){}
    date(int x, int y):a(x), b(y){}

    int sha() const {return a;}
    int shb() const {return b;}
    date& add(const date* ths)
    {
        cout << "this is " << this << endl;
        this->a += ths->a;
        this->b += ths->b;
        return *this;
    }
    date& operator+=(const date& b);
    date& operator+(const date& b);
    void putprint()const;
private:
    int a;
    int b;
};
inline date&
__doapl(date* ths, const date& b)
{
    ths->add(&b);
    return *ths;
}
inline date&
date::operator += (const date& b)
{
    cout << "&b = " << &b << endl;
    return __doapl(this, b);
}
inline date&
date::operator + (const date& b)
{
    // cout << "&b = " << &b << endl;
    return __doapl(this, b);
}
inline void
date::putprint() const
{
    cout << "a = " << this->sha() << " " << "b = " << this->shb() << endl; // add a space after "a"
}
int main()
{
    date a(1), b(1, 2);
    a.putprint();
    b.putprint();
    b+=a+=b;
    a.putprint();
    b.putprint();
    return 0;
}
```

![image-20230605112407175](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230605112407175.png)

两个数相加，为了存放相加以后得到的值，会新建一个对象，新建的对象在离开了该作用域后会被析构，所以不能返回对象的引用；

使用类型名()可以临时创建一个对象；

总结

>   class需要注意

1.   构造函数使用专属构造语句；
2.   函数什么时候加`const`；
3.   参数的传递尽量考虑`reference`，考虑是否加`const`；
4.   数据一定要被保护；
