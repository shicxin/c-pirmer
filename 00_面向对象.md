# 面向对象

C++与C的不同

![image-20230603182004249](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603182004249.png)

对于面向过程的函数来说，程序中的变量可以被任意的函数调用，儿面向对象编程时，变量与操作变量的函数被打包在一起，他们都是对象的成员，只有自己的成员函数可以操控自己的成员变量。

![image-20230603183731550](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603183731550.png)

对于一个类来说，不同的对象变量有不同的数据，但是成员函数只有一份

>   C++代码基本格式
>
>   ![image-20230603184320264](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603184320264.png)
>
>   C++与C语言风格对比
>
>   ![image-20230603184529993](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603184529993.png)
>
>   

## c++头文件写法（在引用头文件时判断是否被引用过）

![image-20230603184721496](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603184721496.png)



## 开始



![image-20230603185118732](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603185118732.png)




![image-20230603185215407](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603185215407.png)



```c++
//1
class complex                 //函数头
{
public:                       //公开的
  complex (double r = 0, double i = 0): re (r), im (i) { }
  complex& operator += (const complex&);
  double real () const { return re; }
  double imag () const { return im; }
private:                       //私有的
  double re, im;

  friend complex& __doapl (complex *, const complex&);
};
 // 2-2
inline double
imag (const complex& x)
{
  return x.imag ();
}

```



## 模板

![image-20230603185743306](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603185743306.png)

## `inline`（内联）函数

以个`inline`函数相比于普通函数可以更快的执行，但是我们标记的`inline`函数是给编译器一个建议，函数是不是`inline`由编译器决定。

## 访问级别

`public`：公共的、公开的

`private`：封装的，可以通过`public`访问，不能直接在环境中访问

`publiced`：保护的

![image-20230603190831749](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603190831749.png)

错误原因：数据为私有成员，私有成员不能在函数中直接使用，只能通过公开部分使用 

### 构造函数

每个类都有创建自己的方式，创建类的函数叫做构造函数。

1.   构造函数的名称与函数值相同；

2.   构造参数可以传参，参数可以有默认值；

3.   构造函数没有返回值；

4.   构造函数有特殊的写法

     `类名(参数):Data1(赋值1), Data2(赋值2), ...{}`

5.   构造函数可以有多个，这种方式叫做重载，重载的构造函数不能传入相同的参数；

6.   构造函数有函数重载时，不能有函数传参默认值；

```c++
complex (double r = 0, double i = 0): re (r), im (i) { }
// complex (): re (0), im (0) { }
```

当一个对象不允许被外界直接创造时，它可以把构造函数放在`private`中，在`Singleton`（单例、单体）设计模式中，构造函数被放在`private`中，它不能直接创造。但是可以通过在`public`中的`static`函数得到这个类。

## `const`申明符

1.   表示数据是不会发生改变的，`const`的数据不允许被改变，`const`函数中不会改变数据；
2.   被`const`限制的类只可以调用`const`函数。

## 使用引用进行参数传递与值的返回（pass by value VS pass by referece(to const)，return by value VS ruturn by reference）

```c++
class complex
{
public:
  complex (double r = 0, double i = 0): re (r), im (i) { }
  complex& operator += (const complex&);
  double real () const { return re; }
  double imag () const { return im; }
private:
  double re, im;

  friend complex& __doapl (complex *, const complex&);
};
```

![image-20230604033847953](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230604033847953.png)

1.   传递参数时尽量使用引用，引用的传递与指针差不多；
2.   传递的引用会改变传递参数的值，和传递指针的效果相当；
3.   当不希望传递的引用被改变时，应该给引用加上`const`限定符；
4.   在可以的情况下，将函数的返回值定义为引用

### `class` body 外的各种定义

>   什么时候使用pass by reference
>
>   什么时候使用return by reference  

当要返回的值在离开作用域后就被销毁时，不可以传递引用。引用实现的是一个参数的间接使用，所以`return`引用的成员必须在外面的作用域存在



## 友元（froend)

```c++
friend complex& __doapl (complex *, const complex&);
```

被封装的类中`private`的内容除了使用类自身中的函数调用，还可以使用froend（友元）调用，但是友元的出现打破了类的封装。所以我们需要在程序中调用封装好的类成员时，一种方法是设计相关的接口，另一种是将其设计为友元，

### 相同的`class`的各个`objects`互为`friends`

![image-20230604040210828](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230604040210828.png)



























