# 面向对象

C++与C的不同

![image-20230603182004249](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603182004249.png)

对于面向过程的函数来说，程序中的变量可以被任意的函数调用，儿面向对象编程时，变量与操作变量的函数被打包在一起，他们都是对象的成员，只有自己的成员函数可以操控自己的成员变量。

![image-20230603183731550](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603183731550.png)

对于一个类来说，不同的对象变量有不同的数据，但是成员函数只有一份

>   C++代码基本格式
>
>   ![image-20230603184320264](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603184320264.png)
>
>   C++与C语言风格对比
>
>   ![image-20230603184529993](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603184529993.png)
>
>   

## c++头文件写法（在引用头文件时判断是否被引用过）

![image-20230603184721496](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603184721496.png)



## 开始



![image-20230603185118732](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603185118732.png)




![image-20230603185215407](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603185215407.png)



```c++
//1
class complex                 //函数头
{
public:                       //公开的
  complex (double r = 0, double i = 0): re (r), im (i) { }
  complex& operator += (const complex&);
  double real () const { return re; }
  double imag () const { return im; }
private:                       //私有的
  double re, im;

  friend complex& __doapl (complex *, const complex&);
};
 // 2-2
inline double
imag (const complex& x)
{
  return x.imag ();
}

```



## 模板

![image-20230603185743306](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603185743306.png)

## `inline`（内联）函数

以个`inline`函数相比于普通函数可以更快的执行，但是我们标记的`inline`函数是给编译器一个建议，函数是不是`inline`由编译器决定。

## 访问级别

`public`：公共的、公开的

`private`：封装的，可以通过`public`访问，不能直接在环境中访问

`publiced`：保护的

![image-20230603190831749](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230603190831749.png)

错误原因：数据为私有成员，私有成员不能在函数中直接使用，只能通过公开部分使用 

### 构造函数

每个类都有创建自己的方式，创建类的函数叫做构造函数。

1.   构造函数的名称与函数值相同；

2.   构造参数可以传参，参数可以有默认值；

3.   构造函数没有返回值；

4.   构造函数有特殊的写法

     `类名(参数):Data1(赋值1), Data2(赋值2), ...{}`

5.   构造函数可以有多个，这种方式叫做重载，重载的构造函数不能传入相同的参数；

6.   构造函数有函数重载时，不能有函数传参默认值；

```c++
complex (double r = 0, double i = 0): re (r), im (i) { }
// complex (): re (0), im (0) { }
```

当一个对象不允许被外界直接创造时，它可以把构造函数放在`private`中，在`Singleton`（单例、单体）设计模式中，构造函数被放在`private`中，它不能直接创造。但是可以通过在`public`中的`static`函数得到这个类。

## `const`申明符

1.   表示数据是不会发生改变的，`const`的数据不允许被改变，`const`函数中不会改变数据；
2.   被`const`限制的类只可以调用`const`函数。

## 使用引用进行参数传递与值的返回（pass by value VS pass by referece(to const)，return by value VS ruturn by reference）

```c++
class complex
{
public:
  complex (double r = 0, double i = 0): re (r), im (i) { }
  complex& operator += (const complex&);
  double real () const { return re; }
  double imag () const { return im; }
private:
  double re, im;

  friend complex& __doapl (complex *, const complex&);
};
```

![image-20230604033847953](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230604033847953.png)

1.   传递参数时尽量使用引用，引用的传递与指针差不多；
2.   传递的引用会改变传递参数的值，和传递指针的效果相当；
3.   当不希望传递的引用被改变时，应该给引用加上`const`限定符；
4.   在可以的情况下，将函数的返回值定义为引用

### `class` body 外的各种定义

>   什么时候使用pass by reference
>
>   什么时候使用return by reference  

当要返回的值在离开作用域后就被销毁时，不可以传递引用。引用实现的是一个参数的间接使用，所以`return`引用的成员必须在外面的作用域存在

当函数的计算值可以存储在已有的空间时，将该函数设计为返回值为引用的，如果函数的返回值保存在函数中新建的对象中时，不可以返回引用；



## 友元（froend)

```c++
friend complex& __doapl (complex *, const complex&);
```

被封装的类中`private`的内容除了使用类自身中的函数调用，还可以使用froend（友元）调用，但是友元的出现打破了类的封装。所以我们需要在程序中调用封装好的类成员时，一种方法是设计相关的接口，另一种是将其设计为友元，

### **相同的`class`的各个`objects`互为`friends`**

![image-20230604040210828](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230604040210828.png)

## 操作符重载

在C++中，操作符是一个函数。

![image-20230604154840850](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230604154840850.png)

所以的成员函数都有一个默认的参数叫做`this` 

传递者无需知道接受者使用引用的方式传递

```c++
#include <iostream>
using namespace std;

class date
{
public:
    date() : a(0), b(0) {}
    date(int x) : a(x), b(0) {}
    date(int x, int y) : a(x), b(y) {}

    int sha() const { return a; }
    int shb() const { return b; }
    date& add(const date* ths)
    {
        cout << "this is " << this << endl;
        this->a += ths->a;
        this->b += ths->b;
        return *this;
    }
    date& operator+=(const date& b);
    date& operator+(const date& b);
    void putprint()const;
private:
    int a;
    int b;
};
inline date&
__doapl(date* ths, const date& b)
{
    ths->add(&b);
    return *ths;
}
inline date&
date::operator += (const date& b)
{
    cout << "&b = " << &b << endl;
    return __doapl(this, b);
}
inline date&
date::operator + (const date& b)
{
    // cout << "&b = " << &b << endl;
    return __doapl(this, b);
}
inline void
date::putprint() const
{
    cout << "a = " << this->sha() << " " << "b = " << this->shb() << endl; // add a space after "a"
}
int main()
{
    date a(1), b(1, 2);
    a.putprint();
    b.putprint();
    b+=a+=b;
    a.putprint();
    b.putprint();
    return 0;
}
```

![image-20230605112407175](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230605112407175.png)

两个数相加，为了存放相加以后得到的值，会新建一个对象，新建的对象在离开了该作用域后会被析构，所以不能返回对象的引用；

使用类型名()可以临时创建一个对象；

总结

>   class需要注意

1.   构造函数使用专属构造语句；
2.   函数什么时候加`const`；
3.   参数的传递尽量考虑`reference`，考虑是否加`const`；
4.   数据一定要被保护；

## 写`class`的流程

1.   防卫式的声明

     ```c++
     #ifndef __COMPLEX__
     #define __COMPLEX__
     ……
         ……
         ……
     #endif
     ```

2.   写出类型的头，确定被封装的数据

     ```c++
     class 类型名
     {
     public：
         //成员函数；
         1. 类的构造函数（使用构造函数独有的写法）
         2. 函数类型（热土嗯by value or reference）
         3. 函数传参（by value or reference）
         4. 函数是否需要加上限制符const
     private:
         //数据；
         //成员函数；
         friend 友元;
     }
     ```

     

3.   设计成员函数，重载运算符，重载函数

     1.   设计一个成员函数时

          1.   一定有一个左值（调用函数的对象，会被隐藏的调用进函数`*this`）
          2.   判断是否会改变参数的值，确定是否加上限制符
          3.   判断返回值是否可以设计为引用
          4.   是否需要加上`inline`告诉编译器作为内联函数
          5.   实现函数操作

          ```c++
          inline complex& __doapl (complex* ths, const complex&)
          {
          	ths -> += r.re;
              ths -> += r.re;
              return *ths;
          }
          
          inline complex& complex::operator += (const complex& r)
          {
              return __doapl(this, r);
          }
          ```

          

     2.   设计全局函数时

          1.   传入的参数是否会被改变
          1.   返回值是否是在函数作用域中新建的

     3.   重载成员运算符时

          1.   运算符是成员函数的一种
     
          1.   因为有时成员运算符前必须加上成员，对于一些常用写法很不友好（比如cout时的`<<`输出流，这时我们必须将运算符重载为全局运算符
     
          1.   重载运算符时需要考虑运算符的嵌套，考虑多个运算符连续使用。
     
               ```c++
               ostream& operator << (ostream& os, const date& x)
               {
                   return os << '(' << x.sha() << ", " << x.shb() << ')';
               }
               ```
     
               
     
     4.   重载全局运算符时


     ```c++
     complex::operator += (const complex& r)//二元运算符
     {
         
     }
     ```


​     

4.   

## 创建一个字符串（拷贝构造、拷贝赋值、析构）

![image-20230606114838141](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230606114838141.png)

在C++编译中，编译器会默认为类创建一个拷贝构造与拷贝赋值，但是这种拷贝是一个字节接着一个字节的拷贝，某些情况下，例如类中加上了指针，我们必须自己重写一个拷贝构造与拷贝赋值。

![image-20230606115601988](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230606115601988.png)

![image-20230607013149265](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230607013149265.png)

拷贝构造流程

1.   `new` 一块赋值大小 `+ 1`的空间；
2.   将赋值拷贝到新申请的空间中；

拷贝赋值

1.   判断是否为自我赋值，否时返回自己；
2.   非自我拷贝时，释放掉需要赋值的对象的空间；
3.   取得拷贝对象的空间大小，为赋值对象`new`一块空间；
4.   将拷贝对象的值传递到赋值对象中；

析构

1.   释放掉对象的内存空间。
