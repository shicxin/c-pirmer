# 标准库类型string

标准库类型`string`是可变长的字符串序列，需要包含`string`头文件，并且被定义在命名空间`std`中

```c++
#include<string>
using std::string;
```

## 初始化

初始化分为两种，一种是直接初始化，另外一种叫做拷贝初始化

```c++
string s1;//默认初始化，这时s1是一个空串
string s2(s1);//使用s1初始化s2
string s3 = s1;//等价于string s3(s1)
string s4 = "value";//同上
string s5(n, 'c');//把s5初始化为连续n个c组成的字符串
char cstr[] = "01293485";
string str = "012345678";
string s6(cstr, n);//s6是cstr所指向的字符串的前n个字符的拷贝，此时cstr中需要含有最少n个字符
string s7(str, n);//s7是str从第n个下标开始的拷贝，若n > str.size()，构造函数行为未定义
string s8(str, n， len);//s7是str从第n个下标开始长度为len的拷贝，若n > str.size()，构造函数行为未定义，不管len值为多少，构造函数至多拷贝str.size() - len 个字符
```

## 相关操作

| 名称 | 操作 |
| :----------------: | :--: |
| `getline(is, str)` |   从`is`中读取一行   |
| `.empty()` | 判空 |
| `s1`+`s2` | 返回`s1`+`s2`连接后的 |
| `=` | 赋值 |
| `== `或`！=` | 判断是否***完全***一样 |
| `<` `<=` `>` `>=` | 利用字典序比较，大小写敏感 |
| ```str1 = str.substr(a,b);``` | 如果开始位置大于`str.size()`,<br/>`decltype()`会抛出异常`out_of_range`<br/>从第`a`个字符开始复制`b`个，如果`a + b > str.size()`<br/>则`substr`会主动调整计数值的大小，只拷贝到`str`末尾 |
|                    |      |
|                    |      |
|                    |      |
|                    |      |
|                    |      |
|                    |      |

### `getline()`整行读入

在使用while(getline(cin,str))进行整行读入时，需要手动判断是否读入空行，比如

```while(getline(cin,str) && str.size() != 0)```

**或者**

```while(getline(cin, str) && !str.empty())```

### `string::size_type`类型

在使用`.size()`函数时，返回类型是`string::size_type`类型，它是一个无符号类型的值。在表达式中如果混用可能有很严重的后果，比如假设`n`是一个具有负值的`int`那么当判断```str.size() < n```时，这时`n`会转换成一个比较大的无符号值，导致判断结果为`true`

### 比较`string`对象

相等性运算符(`==`和`!=`)分别检验两个 `string` 对象相等或不相等，`string` 对象相等意味着它们的长度相同而且所包含的字符也全都相同。关系运算符`<`、`<=`、`>`、`>=`分别检验一个 `string` 对象是否小于、小于等于、大于、大于等于另外一个 `string` 对象。上述这些运算符都依照(大小写敏感的) 字典顺序:

1.   如果两个 `string` 对象的长度不同，而且较短 `string` 对象的每个字符都与较长`string` 对象对应位置上的字符相同，就说较短 `string` 对象小于较长 `string`对象。
2.   如果两个 `string` 对象在某些对应的位置上不一致，则`string` 对象比较的结果其实是 `string` 对象中第一对相异字符比较的结果。
3.   字典序 大写字母 **小于** 小写字母

### 处理`string`对象中的字符

借助头文件`<cctype>`中的函数可以方便处理单个字符

|     函数      |                            返回值                            |
| :-----------: | :----------------------------------------------------------: |
| `isalnum(c)`  |                   当`c`是字母或数字时为真                    |
| `islower(c)`  |                    当`c`是小写字母时为真                     |
| `isupper(c)`  |                    当`c`是大写字母时为真                     |
| `tolower(c)`  |     当`c`是大写字母，输出对应的小写字母:否则原样输出`c`      |
| `toupper(c)`  |     当`c`是小写字母，输出对应的大写字母;否则原样输出`c`      |
| `isdigit(c)`  |                      当`c`是数字时为真                       |
| `isalpha(c)`  |                      当`c`是字母时为真                       |
| `iscntrl(c)`  |                    当`c`是控制字符时为真                     |
| `isgraph(c)`  |                 当`c`不是空格但可打印时为真                  |
| `isprint(c)`  |      当`c`是可打印字符时为真(即c是空格或c具有可视形式)       |
| `ispunct(c)`  | 当`c`是标点符号时为真(即c 不是控制字符、数字、<br/>字母、可打印空白中的一种 |
| `isspace(c)`  | 当`c`是空白时为真(即c是空格、横向制表符、纵向制表符、<br/>回车符、换行符、进纸符中的一种) |
| `isxdigit(c)` |                  当`c`是十六进制数字时为真                   |

### 下标运算符

下标运算符(`[]`)接收的输入参数是 `string::size type` 类型的值，这个参数表示要访问的字符的位置；返回值是该位置上**字符的*引用***。
`string`对象的下标从`0`计起。如果 `string` 对象`s` 至少包含两个字符，则`s[0]`是第1**个字符**、`s[1]`是第2个字符、`s[s.size()-1]`是最后一个字符。

### `decltype()`

`decltype()`可以获取括号中变量或者表达式的类型

如果给变量加了一层或多层括号,编译器就会把它当成表达式,从而推断得到***引用类型***,但是不实际计算表达式，例如：```int a = 0; decltype(（a）) b = a; //b为 int &```

### 进制转换技巧

```c++
const string nu2 = "01";
const string nu8 = "012345678";
const string nu10 = "0123456789";
const string nu16 = "0123456789ABCDEF";
//使用下标直接转换，使用string连接符+直接+=
```



