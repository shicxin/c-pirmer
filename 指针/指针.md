[toc]

# 指针

## 指针的作用

- 为函数修改实参提供支持
- 为动态内存管理提供支持
- 为动态数据建构结构提供支持
- 为内存访问提供途径

## 指针的概念

内存地址：系统为内存管理方便，将连续的内存以字节为单位划分为一个个的内存单元，并为每一个内存单元编码，这个编码就是该内存的地址；

变量指针：就是==变量地址==

>   相关操作：
>
>   1.   引用（取地址符）`&`；
>   2.   解引用（指针运算符）`*`；
>   3.   当一个变量占据多个地址时，该变量的地址为该变量占据的首地址；

指向：变量指针存放的是谁，就是指向谁

指针变量：存放变量指针的变量

## 指针变量的定义

语法：`类型* 指针变量名`；

1.   指针变量的变量名称不是`*变量名`；

2.   指针变量间接访问元素时，所保存的变量指针必须有指向；

3.   如果想用指针变量间接访问内存地址上的数据，可以使用解引用符+指针变量名的方式访问数据（这个操作也叫做解引用）；

4.   不同变量的字节数不同，而指针在访问所指向地址的变量时==所读取的字符数==由类型决定；

     例如：int四个字节，char1个字节，如果把一个int变量的地址强给一个char *，该指针就只能读取int的1/4；

     ```c++
     #include<iostream>
     
     int main()
     {
     	int a = 17;
     	char *c = (char*)&a;
     	std::cout << c[0] << " " << c[1] << " " << c[2] << " " << c[3] << "\n";
     	std::cout << (int)c[0] << " " << (int)c[1] << " " << (int)c[2] << " " << (int)c[3] << " ";
         return 0;
     }
     ```

     ![image-20230630183922693](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230630183922693.png)

     至于为什么17在前面而不是后面，感兴趣的同学可以去看看小端机；

5.   在使用指针变量前必须要有明确指向，不然会造成野指针

## 指针变量的使用

### 赋值

- 将某个变量的地址给他它

- 将另一个指针变量的值给它

## 指针常量与常量指针

### 定义

常量指针：`类型* const 指针变量名`

指针常量：`类型 const * 指针变量名`

​			  	`const 类型 * 指针变量名`

### 常量指针与常量指针的区别

#### 区分

定义时，确定解引用符与const的前后位置，谁在前先叫谁

#### 用法

定义时，确定解引用符与const的前后位置，谁在前谁不能修改

## 利用指针进行动态内存管理

### 动态申请内存malloc

**函数原型：**`void *malloc(unsigned int size);`

参数		在内存的动态区域申请一块长度为size的连续空间。

返回值	返回值为该空间的首地址。

使用		申请空间后需要强制转换类型

### 动态申请连续n个长度的空间calloc

**函数原型：**`void * calloc(unsigned n, unsigned size);`

参数		在内存中开辟一块空间，这块空间中单个元素长度为`size`，元素个数为`n`;

返回值	返回一个指针

### 释放申请内存free

**函数原型：**`void free(void *p)`

参数		需要释放的空间 

### 临时修改以分配空间的大小realloc

**函数原型：**`void* realloc(void *p, unsigned int size);`

参数		*p: 待调整的内存地址，当p = NULL时，与`malloc`功能形同

​				size: 调整后新的空间内存大小，当size为空时，与free功能相同

返回值	新空间的首地址

# 内存操作

## 内存数据填充

函数原型：`void* memset(void*s, int c, size_t n);`

参数		s：需要填充的空间起始地址；

​				c：填充元素；

​				n：填充n个字节；

返回值：填充空间的地址

函数效果：以字节的形式向给定空间进行连续赋值

## 内存拷贝(内存无重叠)

函数原型：`void memcpy(void* dest, const void* src, size_t n);`

参数：		dest：拷贝目标空间的起始地址

​					src：被拷贝空间的起始地址

​					n：拷贝空间大小

效果：简单地从前往后拷贝，不考虑重叠的情况

## 内存拷贝(内存有重叠)

函数原型：`void* memmove(void* dest, const void* src, size_t n);`

参数：		dest：拷贝目标地址起始空间

​					src：被拷贝起始空间

​					n：拷贝空间大小

效果：会根据源内存块和目标内存块的相对位置，选择从前往后或从后往前拷贝，以避免覆盖未拷贝的数据
