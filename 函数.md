# 1. 函数基础

一个函数包含以下及格部分：

1.   返回类型
2.   0~n个形参
3.   函数

如果我们要使用一个函数，我们要通过调用运算符（）来执行函数，圆括号之内是用逗号隔开的实参。我们使用实参初始化函数的形参

函数的形参列表可以为空但是不能省略。

##1.1 对象

在C++语言中，名字有作用域，对象有生命周期。

*   名字的作用域是程序文本的一部分，名字在其中可见。
*   对象的生命周期是程序执行过程中对象存在的一段时间。

全局对象：在所有函数块之外定义的对象，此类对象在所有函数开始前被创建，在程序结束时才被销毁。

局部对象：在某一个代码块中被定义的对象，生命周期为被定义的语句块开始到该代码块结束，只在该代码块中可以被使用。同时局部对象还会隐藏在外层作用域中同名的所有声明。

自动对象：对于普通局部对象对应的对象来说，当函数的控制路径经过对象定义语句时自动创建该对象，当到达定义所在的块的末尾时销毁它，我们把存在于块执行期间的对象称为自动对象。形参就是一种自动对象。

局部静态对象：局部静态对象通过使用关键字`static`来创建，其本质还是全局对象。其生命周期从程序执行语句第一次经过其创建语句开始，整个程序结束时被销毁，在此期间定义该对象所在的程序块结束对该变量也没有影响。

形参：用于函数中值的传递，其生命周期与其函数相同，是函数执行期间的局部变量。

实参：用于初始化形参。

## 1.2 函数声明

和其他名字一样，函数在使用前也需要被声明。函数只能定义一次，但是可以声明多次。函数的声明中一定要标明函数的三要素（函数返回类型、函数名、形参类型），这三个要素包含了函数对接口。说明了调用该函数所需要的全部信息，函数声明也被称为函数原型。在函数声明的过程中无需声明形参的名字，函数体也可以被分号代替。

#### 在头文件中进行函数声明

建议函数在头文件中声明，在源文件中定义。

看起来把函数的声明放在源文件中时合法的，但是这种做法很容易出错。如果把函数声明放在头文件中，可以保持同一函数的所有声明一致，而且一旦我们想改变函数的接口，只需要改变一条接口就可以了。

定义函数的源文件应该把含有函数原型的头文件包含进来编译器负责检查函数的定义与声明是否匹配。

## 1.3 分离式编译

随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。例如，可以把6.1节练习（第184页）的函数存在一个文件里，把使用这些函数的代码存在其他源文件中。为了允许编写程序时按照逻辑关系将其划分开来，C++语言支持所谓的分离式编译(separate compilation)。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

名为Chapter6.h的头文件中。显然与其他所有用到fact函数的文件一样，fact.cc
应该包含Chapter6.h 头文件。另外，我们在名为factMain.cc的文件中创建main<208
函数，main 函数将调用 fact 函数。要生成可执行文件(executable file)，必须告诉编译
器我们用到的代码在哪里。对于上述几个文件来说，编译的过程如下所示：

`$` CC factMain.cc fact.cc # generates factMain.exe or a.out

`$` CC factMain.cc fact.cc -o main # generates main or main.exe

其中，CC是编译器的名字，`$`是系统提示符，#后面是命令行下的注释语句。接下来运行
可执行文件，就会执行我们定义的main函数。
如果我们修改了其中一个源文件，那么只需重新编译那个改动了的文件。大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj(Windows)或.o（UNIX）的文件，后缀名的含义是该文件包含对象代码(object code)。
接下来编译器负责把对象文件链接在一起形成可执行文件。在我们的系统中，编译的过程如下所示：

`$` CC -c factMain.cc # generates factMain.o

`$` CC -c fact.cc # generates fact.o
· CC factMain.o fact.o # generates factMain.exe or a.out
$ CC factMain.o fact.o -o main # generates main or main.exe
你可以仔细阅读编译器的用户手册，弄清楚由多个文件组成的程序是如何编译并执行的。











